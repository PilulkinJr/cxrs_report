\documentclass[../main.tex]{subfiles}

\begin{document}

This section is aimed to help future developers in their work on \texttt{cxrs}. Most of the functions implemented in this project contain docstrings written in \enquote{classic} Python style using \textbf{reStructuredText} syntax. Each docstring contains a short description of a function, list of arguments and their types and list of exceptions which can be risen during execution of the function, but description for some of the arguments can be missing.

Also this section tries to be a proper documentation for a software project. But, really, it is more of a reasoning for why \emph{this thing is done like that and not like this}.

\subsection{Project Structure}%
\label{sec:project_structure}

\texttt{cxrs} project is divided in several modules, each in its respective folder:

\dirtree{%
    .1 /.
    .2 cxrs/.
    .3 imas/.
    .4 \_\_init\_\_.py.
    .4 charge\_exchange.py.
    .4 core\_profiles.py.
    .4 edge\_profiles.py.
    .4 equilibrium.py.
    .4 find\_nearest.py.
    .4 ids.py.
    .4 nbi.py.
    .3 machine/.
    .4 portplugs/.
    .4 simple/.
    .4 \_\_init\_\_.py.
    .4 pfc\_mesh.py.
    .3 model/.
    .4 \_\_init\_\_.pxd.
    .4 \_\_init\_\_.py.
    .4 passive.pxd.
    .4 passive.pyx.
    .3 observers/.
    .4 \_\_init\_\_.py.
    .4 base.py.
    .4 camera.py.
    .4 fibre\_bundle.py.
    .4 fibres.py.
    .4 optics.py.
    .4 scanner.py.
    .4 sightlines.py.
    .4 spectrometer.py.
    .4 total\_radiance.py.
    .3 populate/.
    .4 \_\_init\_\_.py.
    .4 create.py.
    .4 openadas.py.
    .3 subprograms/.
    .4 \_\_init\_\_.py.
    .4 composition.py.
    .4 idslist.py.
    .4 info.py.
    .4 local\_copy.py.
    .4 populate.py.
    .4 read\_ids.py.
    .4 search.py.
    .4 simulate.py.
    .4 write\_ids.py.
    .3 utility/.
    .4 \_\_init\_\_.py.
    .4 info/.
    .5 \_\_init\_\_.py.
    .5 beam.py.
    .5 equilibrium.py.
    .5 passive.py.
    .5 plasma.py.
    .5 profiles.py.
    .4 annotation.py.
    .4 data.py.
    .4 emission.py.
    .4 fit.py.
    .4 math.py.
    .4 timer.py.
    .4 xml.py.
    .3 \_\_init\_\_.py.
    .3 \_\_main\_\_.py.
    .3 create\_beam.py.
    .3 env.sh.
    .3 matplotlibrc.
    .2 tests/.
    .2 .gitignore.
    .2 config.xml.
    .2 env.sh.
    .2 MANIFEST.in.
    .2 matplotlibrc.
    .2 README.md.
    .2 requirements.txt.
    .2 setup.cfg.
    .2 setup.py.
}

\subsection{\texttt{imas} module~--~Interaction with IMAS database}%
\label{sec:reading_from_imas}

Module responsible for reading data from IMAS and creating appropriate plasma and DNB models is stored in \texttt{cxrs\//imas} directory.

\subsubsection{Supplementary Functions}%
\label{sec:imas_supp}

\paragraph{\texttt{ids\_get}}%
\label{par:ids_get}

File \texttt{ids.py} contains only one function \texttt{ids\_get} which is used to check and load requested IDS. For example

\begin{minted}{python}
    charge_exchange_ids = ids_get(
        name="charge_exchange",
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
        occurrence=0
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{name}] is a name of requested IDS,
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
    \item[\texttt{occurrence}] is an IDS occurrence number. Each IDS can store several \texttt{occurrences} (refer to the description of an IDS). For example in \texttt{charge\_exchange} IDS occurrences used to store data related to different diagnostics.
\end{itemize}

\paragraph{\texttt{find\_nearest}}%
\label{par:find_nearest}

File \texttt{find\_nearest.py} contains only one function \texttt{find\_nearest}. It is used for locating an index of the nearest time slice to the time requested by user.

Example:
\begin{minted}{python}
    idx = find_nearest(
        array=time_slices,
        value=260,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{array}] is an input array,
    \item[\texttt{value}] is a value to search for.
\end{itemize}

\subsubsection{\texttt{equilibrium} IDS}%
\label{sec:equilibrium_ids}

File \texttt{equilibrium.py} contains \texttt{EquilibriumIDS} class which is used to read data from \\ \texttt{equilibrium} IDS and create CHERAB's \href{https://cherab.github.io/documentation/plasmas/equilibrium.html?highlight=efit#cherab.tools.equilibrium.efit.EFITEquilibrium}{\texttt{EFITEquilibrium}} object via \texttt{time} method. It is later used to build core plasma model.

Load an \texttt{equilibrium} IDS:
\begin{minted}{python}
    equilibrium_ids = EquilibriumIDS(
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
\end{itemize}

Create an \texttt{EFITEquilibrium} object:
\begin{minted}{python}
    equilibrium = equilibrium.time(time=-1)
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{time}] is a requested time. Here \texttt{-1} for time is used to acquire a time slice in the middle of time range.
\end{itemize}

Other methods:
\begin{itemize}[align=left]
    \item[\texttt{ids()}] returns the \texttt{equilibrium} IDS object;
    \item[\texttt{psi\_1d()}] returns one-dimensional $\Psi$ profile stored in \texttt{ids.time\_slice[i].profiles\_1d.psi}. It is implemented in case if \texttt{core\_profiles}~(\cref{sec:core_profiles_ids}) IDS does not contain its own profile.
\end{itemize}

\subsubsection{\texttt{core\_profiles} IDS}%
\label{sec:core_profiles_ids}

File \texttt{core\_profiles.py} contains \texttt{CoreProfilesIDS} class which is used to read data from \texttt{core\_profiles} IDS and create CHERAB's \href{https://cherab.github.io/documentation/plasmas/core_plasma_classes.html?highlight=plasma#cherab.core.Plasma}{\texttt{Plasma}} object via \texttt{create\_plasma} method. It is poses as core plasma model.

Load a \texttt{core\_profiles} IDS:
\begin{minted}{python}
    core_profiles_ids = CoreProfilesIDS(
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
\end{itemize}

Create a \texttt{Plasma} object:
\begin{minted}{python}
    core_plasma = core_profiles_ids.create_plasma(
        equilibrium=equilibrium,
        psi_1d=equilibrium.psi_1d(),
        integration_step=0.001,
        integration_samples=5,
        parent=world,
        transform=None,
        name="Core Plasma"
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids});
    \item[\texttt{psi\_1d}] is one-dimensional $\Psi$ profile~(\cref{sec:equilibrium_ids}). It is used if one stored in \texttt{core\_profiles} IDS is missing;
    \item[\texttt{integration\_step}] is step of volumetric integration in meters;
    \item[\texttt{integration\_samples}] is a number of integration samples;
    \item[\texttt{parent}] is a parent node;
    \item[\texttt{transform}] is transformation matrix;
    \item[\texttt{name}] is a name of this plasma.
\end{itemize}
\emph{Note: } for more information on \texttt{integration\_step} and \texttt{integration\_samples} refer to CHERAB's documentation on \href{https://cherab.github.io/documentation/plasmas/core_plasma_classes.html?highlight=plasma#cherab.core.Plasma}{\texttt{Plasma}}.
For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/core/raysect_core_scenegraph.html?highlight=node#raysect.core.scenegraph.node.Node}{\texttt{Node}}.

\emph{Note} that \texttt{create\_plasma} method does not require time value since it uses one that stored in \texttt{equilibrium}.

One required argument of \texttt{create\_plasma} is \texttt{equilibrium}. It provides $\Psi_\text{norm}$ distribution which is used to map density, temperature and bulk velocity distributions of plasma. Functions \texttt{distribution\_density}, \texttt{distribution\_temperature} and \texttt{distribution\_velocity} are doing exactly that. \emph{Note:} \texttt{distribution\_temperature} tries to use average ion temperature or electron temperature if species' own temperature profile is absent in the IDS.

\paragraph{\texttt{detect\_species}}%
\label{par:detect_species}

Function \texttt{detect\_species} is used to recognize ion and neutral species from label given in IDS. Since there was no convention on the labeling at the time this appeared to be a huge problem. \texttt{detect\_species} uses regular expressions to math species label along some other tricks. It returns CHERAB's \href{https://cherab.github.io/documentation/atomic/elements_and_isotopes.html?highlight=element#cherab.core.atomic.elements.Element}{\texttt{Element}} object and species charge as a number (0 for neutrals).

\begin{minted}{python}
    species, charge = detect_species(
        structure=core_profiles_ids.ids.profiles_1d[0].ion[0],
        ion=True
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{ion}] set to \mintinline{python}{True} for ion species or to \mintinline{python}{False} for neutrals. It changes regular expression pattern and sets \texttt{charge} to 0 for neutrals.
\end{itemize}

\paragraph{\texttt{distribution\_density}}%
\label{par:distribution_density}

\begin{minted}{python}
    n_d = distribution_density(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
\end{itemize}

This function checks if density profile stored in the IDS is correct: not empty, greater than zero, not equal to zero and not equal to 1.0. If it is not correct than message is produced and this species is not included in the plasma model.

\paragraph{\texttt{distribution\_temperature}}%
\label{par:distribution_temperature}

\begin{minted}{python}
    t_d = distribution_temperature(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium,
        t_average=core_profiles_ids.ids.profiles_1d[i].t_i_average,
        t_electrons=core_profiles_ids.ids.profiles_1d[i].electrons.temperature
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
    \item[\texttt{t\_average}] is an average ion temperature profile stored is the IDS. It is used in case if ion temperature profile for requested species is absent.
    \item[\texttt{t\_electrons}] is an electron temperature profile. It is used in case if ion temperature profile for requested species is absent.
\end{itemize}

\paragraph{\texttt{distribution\_velocity}}%
\label{par:distribution_velocity}

\begin{minted}{python}
    v_d = distribution_velocity(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
\end{itemize}

\subsubsection{\texttt{edge\_profiles} IDS}%
\label{sec:edge_profiles_ids}

File \texttt{edge\_profiles.py} contains \texttt{EdgeProfilesIDS} class which is used to read data from \texttt{edge\_profiles} IDS and create CHERAB's \href{https://cherab.github.io/documentation/plasmas/core_plasma_classes.html?highlight=plasma#cherab.core.Plasma}{\texttt{Plasma}} object via \texttt{create\_plasma} method. It is poses as edge plasma model.

Load a \texttt{edge\_profiles} IDS:
\begin{minted}{python}
    edge_profiles_ids = EdgeProfilesIDS(
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
\end{itemize}

Create a \texttt{Plasma} object:
\begin{minted}{python}
    edge_plasma = edge_profiles_ids.create_plasma(
        time=0.0,
        equilibrium=equilibrium,
        integration_step=0.001,
        integration_samples=5,
        parent=world,
        transform=None,
        name="Edge Plasma"
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{time}] is a requested time;
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids});
    \item[\texttt{integration\_step}] is step of volumetric integration in meters;
    \item[\texttt{integration\_samples}] is a number of integration samples;
    \item[\texttt{parent}] is a parent node;
    \item[\texttt{transform}] is transformation matrix;
    \item[\texttt{name}] is a name of this plasma.
\end{itemize}
\emph{Note: } for more information on \texttt{integration\_step} and \texttt{integration\_samples} refer to CHERAB's documentation on \href{https://cherab.github.io/documentation/plasmas/edge_plasma_classes.html?highlight=plasma#cherab.edge.Plasma}{\texttt{Plasma}}.
For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/edge/raysect_edge_scenegraph.html?highlight=node#raysect.edge.scenegraph.node.Node}{\texttt{Node}}.

\paragraph{\texttt{distribution\_density}}%
\label{par:distribution_density}

\begin{minted}{python}
    n_d = distribution_density(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium,
        interpolator=interp_options[interp],
        interpolation_data=interp_data[interp],
        mesh_lookup=te_mesh_lookup
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
    \item[\texttt{interpolator}] -- select an interpolator based on where values are defined: faces or nodes.
    \item[\texttt{interpolation\_data}] -- select a function to process data based on where values are defined: faces or nodes.
    \item[\texttt{mesh\_lookup}] \emph{empty}
\end{itemize}

All \texttt{interpolator}, \texttt{interpolation\_data} and \texttt{mesh\_lookup} are defined in the body of \texttt{create\_plasma} method.

This function checks if density profile stored in the IDS is correct: not empty, greater than zero, not equal to zero and not equal to 1.0. If it is not correct than message is produced and this species is not included in the plasma model.

\paragraph{\texttt{distribution\_temperature}}%
\label{par:distribution_temperature}

\begin{minted}{python}
    t_d = distribution_temperature(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium,
        interpolator=interp_options[interp],
        interpolation_data=interp_data[interp],
        mesh_lookup=te_mesh_lookup
        t_average=core_profiles_ids.ids.profiles_1d[i].t_i_average,
        t_electrons=core_profiles_ids.ids.profiles_1d[i].electrons.temperature
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
    \item[\texttt{interpolator}] -- select an interpolator based on where values are defined: faces or nodes.
    \item[\texttt{interpolation\_data}] -- select a function to process data based on where values are defined: faces or nodes.
    \item[\texttt{mesh\_lookup}] \emph{empty}
    \item[\texttt{t\_average}] is an average ion temperature profile stored is the IDS. It is used in case if ion temperature profile for requested species is absent.
    \item[\texttt{t\_electrons}] is an electron temperature profile. It is used in case if ion temperature profile for requested species is absent.
\end{itemize}

\paragraph{\texttt{distribution\_velocity}}%
\label{par:distribution_velocity}

\begin{minted}{python}
    v_d = distribution_velocity(
        structure=core_profiles_ids.ids.profiles_1d[i].ion[j],
        symbol="D",
        charge=1,
        psi_normalised=psi_normalised,
        equilibrium=equilibrium,
        interpolator=interp_options[interp],
        interpolation_data=interp_data[interp],
        mesh_lookup=te_mesh_lookup
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{structure}] is an IDS structure containing information on species (\texttt{ids.profiles\_1d[i].ion[j]} or \texttt{ids.profiles\_1d[i].neutral[j]}).
    \item[\texttt{symbol}] is a species symbol. It is used for messages.
    \item[\texttt{charge}] is a species charge. It is used for messages.
    \item[\texttt{psi\_normalised}] is a $\Psi_\text{norm}$ profile. It is used to map density values.
    \item[\texttt{equilibrium}] is an EFITEquilibrium object~(\cref{sec:equilibrium_ids}).
    \item[\texttt{interpolator}] -- select an interpolator based on where values are defined: faces or nodes.
    \item[\texttt{interpolation\_data}] -- select a function to process data based on where values are defined: faces or nodes.
    \item[\texttt{mesh\_lookup}] \emph{empty}
\end{itemize}

\paragraph{\texttt{detect\_species}} is a copy of a function described in~\cref{par:detect_species}.

\subsubsection{\texttt{charge\_exchange} IDS}%
\label{sec:charge_exchange_ids}

File \texttt{charge\_exchange.py} contains \texttt{ChargeExchangeIDS} class which is used to read data from \texttt{charge\_exchange} IDS and create different types of observers.

Load an \texttt{charge\_exchange} IDS:
\begin{minted}{python}
    charge_exchange_ids = ChargeExchangeIDS(
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
\end{itemize}

\subsubsection{\texttt{nbi} IDS}%
\label{sec:nbi_ids}

File \texttt{nbi.py} contains \texttt{NBIIDS} class which is used to read data from \texttt{nbi} IDS and create CHERAB's \href{https://cherab.github.io/documentation/plasmas/particle_beams.html?highlight=beam#cherab.core.Beam}{\texttt{Beam}} object via \texttt{create\_beam} method. It is poses as DNB model.

Load an \texttt{nbi} IDS:
\begin{minted}{python}
    nbi_ids = NBIIDS(
        shot=134000,
        run=30,
        user="public",
        database="iter",
        version="3",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{shot}] is an IMAS database shot ID,
    \item[\texttt{run}] is an IMAS data run ID,
    \item[\texttt{user}] is an IMAS database user ID,
    \item[\texttt{database}] is an IMAS database ID,
    \item[\texttt{version}] is an IMAS major version number,
\end{itemize}

\begin{minted}{python}
    beam = nbi_ids.create_beam(
        time=0.0,
        plasma=core_plasma,
        atomic_data=adas,
        attenuation_instructions=attenuation_instructions,
        emission_instructions=emission_instructions,
        length=4.0,
        integration_step=0.001,
        integration_samples=5,
        parent=world
        transform=None,
        name="DNB"
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{time}] is a requested time;
    \item[\texttt{plasma}] is CHERAB's \texttt{Plasma} object;
    \item[\texttt{atomic\_data}] is modified CHERAB's \texttt{OpenADAS} object;
    \item[\texttt{attenuation\_instructions}] is a dictionary with attenuation instructions;
    \item[\texttt{emission\_instructions}] is a dictionary with emission instructions~(see \cref{sec:emission});
    \item[\texttt{integration\_step}] is step of volumetric integration in meters;
    \item[\texttt{integration\_samples}] is a number of integration samples;
    \item[\texttt{parent}] is a parent node;
    \item[\texttt{transform}] is transformation matrix;
    \item[\texttt{name}] is a name of this plasma.
\end{itemize}
\emph{Note: } for more information on \texttt{integration\_step} and \texttt{integration\_samples} refer to CHERAB's documentation on \href{https://cherab.github.io/documentation/plasmas/particle_beams.html?highlight=beam#cherab.core.Beam}{\texttt{Beam}}.
For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/edge/raysect_edge_scenegraph.html?highlight=node#raysect.edge.scenegraph.node.Node}{\texttt{Node}}.

At the time \texttt{Beam} supports model with only one beamlet and \texttt{create\_beam} is designed with this in mind.

\subsection{Setting the Wall}%
\label{sec:wall}

File \texttt{cxrs/machine/pfc\_mesh.py} contains function \texttt{load\_pfc\_mesh} that is used to create a reactor wall model. All meshes are stored in \texttt{machine/portplugs} and \texttt{machine/simple} subfolders.

\begin{minted}{python}
    wall = load_pfc_mesh(
        path=os.path.join(os.path.dirname(__file__)),
        reflections=True,
        roughness={"Be": 0.26, "W": 0.29, "Ss": 0.13},
        detailed=False,
        parent=world,
        transform=None,
        name="Wall",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{path}] is a path to .rsm mesh files;
    \item[\texttt{reflections}] sets reflections on or off;
    \item[\texttt{roughness}] is a roughness dictionary for PFC materials ("Be", "W", "Ss");
    \item[\texttt{detailed}] -- Load the detailed wall model instead of the simple one;
    \item[\texttt{parent}] is a parent node;
    \item[\texttt{transform}] is a transformation matrix;
    \item[\texttt{name}] is a name of this plasma.
\end{itemize}
Here \texttt{reflections} assigns material properties to appropriate wall segments if set to \texttt{True} and sets the wall as \href{https://raysect.github.io/documentation/api_reference/optical/optical_surfaces.html?highlight=absorber#raysect.optical.material.absorber.AbsorbingSurface}{perfect absorber} if set to \texttt{False}. It is used to effectively turn reflections on and off. \texttt{roughness} argument sets \href{https://raysect.github.io/documentation/demonstrations/materials/surface_roughness.html?highlight=rough}{\emph{roughness}} of the materials assigned to the wall segments (beryllium, tungsten and stainless steel).
For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/edge/raysect_edge_scenegraph.html?highlight=node#raysect.edge.scenegraph.node.Node}{\texttt{Node}}.

\subsection{Observers}%
\label{sec:observers}

Module \texttt{cxrs/observers} contains several files defining different observer classes built upon Raysect's \href{https://raysect.github.io/documentation/api_reference/optical/observers.html?highlight=observer}{observers}.

\subsubsection{Base Class}%
\label{sec:observers_base}

File \texttt{observers/base} contains \texttt{ObserverGroup} class that represents a group of observers, for example CXRS sightlines. The class has \texttt{observe} method that is used to perform an observation by all observers in a group one by one and store the results. Methods \texttt{display} and \texttt{savetxt} are used to show registered spectra as an image or plot and save results in the text format respectively. They should be implemented in subclasses.

Example:
\begin{minted}{python}
    ObserverGroup(
        charge_exchange_ids=charge_exchange_ids,
        config="config.xml",
        wavelength_range=1,
        relative_error=0.05,
        scenario=scenario,
        parent=world,
        transform=None,
        name="CXRS Edge Sightlines"
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{charge\_exchange\_ids}] is a \texttt{ChargeExchangeIDS} object~(\cref{sec:charge_exchange_ids}),
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{wavelength\_range}] is a number representing a wavelength range for observation (it is defined in a configuration file),
    \item[\texttt{relative\_error}] is a minimal value of a desired relative error (if achieved relative error is higher than this value, number of pixel samples will be increased and observation will be performed again until desired relative error is achieved),
    \item[\texttt{scenario}] is a dictionary containing all simulation labels: shot number, run number, time, used emission types, etc.,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/edge/raysect_edge_scenegraph.html?highlight=node#raysect.edge.scenegraph.node.Node}{\texttt{Node}}.

\subsubsection{Sightlines}%
\label{sec:sightlines}

\begin{minted}{python}
    sightlines = SightlineGroup(
        ids=charge_exchange_ids,
        config="config.xml",
        wavelength_range=1,
        relative_error=0.05,
        scenario=scenario,
        parent=world,
        transform=None,
        name="CXRS Sightlines",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{charge\_exchange\_ids}] is a \texttt{ChargeExchangeIDS} object~(\cref{sec:charge_exchange_ids}),
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{wavelength\_range}] is a number representing a wavelength range for observation (it is defined in a configuration file),
    \item[\texttt{relative\_error}] is a minimal value of a desired relative error (if achieved relative error is higher than this value, number of pixel samples will be increased and observation will be performed again until desired relative error is achieved),
    \item[\texttt{scenario}] is a dictionary containing all simulation labels: shot number, run number, time, used emission types, etc.,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

Methods:
\begin{itemize}[align=left]
    \item[\texttt{display}] used to show and save produced image(s):
          \begin{minted}{python}
SightlineGroup.display(
    show=True,
    save=True,
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{show}] -- show produced images in separate window;
              \item[\texttt{save}] -- save images to a disk;
              \item[\texttt{filename}] -- name of the file to save to. Image is saved in .png format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}

    \item[\texttt{savetxt}] used to save simulation results in text format:
          \begin{minted}{python}
SightlineGroup.savetxt(
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{filename}] -- name of the file to save to. Text is saved in .txt format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}

    \item[\texttt{draw\_scheme}] used to draw a simple scheme of a diagnostic:
          \begin{minted}{python}
SightlineGroup.draw_scheme(
    plane="xy",
    save=True,
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{plane}] -- produce a scheme in x-y ("xy") or r-z ("rz") plane;
              \item[\texttt{save}] -- save images to a disk;
              \item[\texttt{filename}] -- name of the file to save to. Image is saved in .png format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}
\end{itemize}

\subsubsection{Optics}%
\label{sec:optics}

\begin{minted}{python}
    optics = OpticsAssembly(
        target_distance=4.0,
        aperture_radius=0.05,
        magnification=0.1,
        refractive_index=1.52,
        parent=None,
        transform=None,
        name="Lens",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{target\_distance}] -- distance to a target in meters;
    \item[\texttt{aperture\_radius}] -- radius of the aperture in meters;
    \item[\texttt{magnification}] -- lens' magnification;
    \item[\texttt{refractive\_index}] -- refractive index of the lens' material;
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

For more information on \texttt{parent}, \texttt{transform} and \texttt{name} refer to Raysect's documentation on \href{https://raysect.github.io/documentation/api_reference/edge/raysect_edge_scenegraph.html?highlight=node#raysect.edge.scenegraph.node.Node}{\texttt{Node}}.

\subsubsection{Fibres}%
\label{sec:fibres}

\begin{minted}{python}
    fibres = FibreGroup(
        ids=charge_exchange_ids,
        config="config.xml",
        wavelength_range=1,
        relative_error=0.05,
        scenario=scenario,
        parent=world,
        transform=None,
        name="CXRS Fibres",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{charge\_exchange\_ids}] is a \texttt{ChargeExchangeIDS} object~(\cref{sec:charge_exchange_ids}),
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{wavelength\_range}] is a number representing a wavelength range for observation (it is defined in a configuration file),
    \item[\texttt{relative\_error}] is a minimal value of a desired relative error (if achieved relative error is higher than this value, number of pixel samples will be increased and observation will be performed again until desired relative error is achieved),
    \item[\texttt{scenario}] is a dictionary containing all simulation labels: shot number, run number, time, used emission types, etc.,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

Methods:
\begin{itemize}[align=left]
    \item[\texttt{display}] used to show and save produced image(s):
          \begin{minted}{python}
FibreGroup.display(
    show=True,
    save=True,
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{show}] -- show produced images in separate window;
              \item[\texttt{save}] -- save images to a disk;
              \item[\texttt{filename}] -- name of the file to save to. Image is saved in .png format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}

    \item[\texttt{savetxt}] used to save simulation results in text format:
          \begin{minted}{python}
FibreGroup.savetxt(
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{filename}] -- name of the file to save to. Text is saved in .txt format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}

    \item[\texttt{draw\_scheme}] used to draw a simple scheme of a diagnostic:
          \begin{minted}{python}
FibreGroup.draw_scheme(
    plane="xy",
    save=True,
    filename="cxrs_sightlines",
    dirname="output"
)
        \end{minted}
          \begin{itemize}[align=left]
              \item[\texttt{plane}] -- produce a scheme in x-y ("xy") or r-z ("rz") plane;
              \item[\texttt{save}] -- save images to a disk;
              \item[\texttt{filename}] -- name of the file to save to. Image is saved in .png format;
              \item[\texttt{dirname}] -- name of the directory to save to.
          \end{itemize}
\end{itemize}

\subsubsection{Camera}%
\label{sec:camera}

\begin{minted}{python}
    ccd_camera = CCDCamera(
        config="config.xml",
        parent=world,
        transform=None,
        name="CXRS Fibres",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

\subsubsection{Other Observers}%
\label{sec:other_observers}

\begin{minted}{python}
    fibre_bundle = FibreBundle(
        core_radius=0.5e-3,
        numerical_aperture=0.22,
        spectrum=,
        n_rows=3,
        n_cols=1,
        relative_error=0.05
        parent=world,
        transform=None,
        name="CXRS Fibres",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{core\_radius}] -- radius of a fibre's core in meters;
    \item[\texttt{numerical\_aperture}] -- fibre's numerical aperture;
    \item[\texttt{spectrum}] -- Raysect's \href{https://raysect.github.io/documentation/api_reference/optical/main_optical_classes.html?highlight=spectrum#raysect.optical.spectrum.Spectrum}{\texttt{Spectrum}} object;
    \item[\texttt{n\_rows}] -- number of rows;
    \item[\texttt{n\_cols}] -- number of columns;
    \item[\texttt{relative\_error}] -- desired relative error;
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

\begin{minted}{python}
    scanner = Scanner(
        ids=charge_exchange_ids,
        config="config.xml",
        range_vertical=0.2,
        step_vertical=0.01,
        relative_error=0.05,
        scenario=scenario,
        parent=world,
        transform=None,
        name="Scanner",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{charge\_exchange\_ids}] is a \texttt{ChargeExchangeIDS} object~(\cref{sec:charge_exchange_ids}),
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{range\_vertical}] -- vertical range in meters;
    \item[\texttt{step\_vertical}] -- size of the scanning step in vertical direction;
    \item[\texttt{relative\_error}] is a minimal value of a desired relative error (if achieved relative error is higher than this value, number of pixel samples will be increased and observation will be performed again until desired relative error is achieved),
    \item[\texttt{scenario}] is a dictionary containing all simulation labels: shot number, run number, time, used emission types, etc.,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

\begin{minted}{python}
    total_radiance = TotalRadianceSightlines(
        ids=charge_exchange_ids,
        config="config.xml",
        relative_error=0.05,
        scenario=scenario,
        parent=world,
        transform=None,
        name="Scanner",
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{charge\_exchange\_ids}] is a \texttt{ChargeExchangeIDS} object~(\cref{sec:charge_exchange_ids}),
    \item[\texttt{config}] is a path to configuration file,
    \item[\texttt{relative\_error}] is a minimal value of a desired relative error (if achieved relative error is higher than this value, number of pixel samples will be increased and observation will be performed again until desired relative error is achieved),
    \item[\texttt{scenario}] is a dictionary containing all simulation labels: shot number, run number, time, used emission types, etc.,
    \item[\texttt{parent}] is a parent node in a scenegraph,
    \item[\texttt{transform}] is a transformation matrix,
    \item[\texttt{name}] is a name for this group of observers.
\end{itemize}

\begin{minted}{python}
    spectrometer = Spectrometer(
        pixel_size=,
        n_pixels=,
        wl_calibration=,
        int_calibration=,
        width=,
        inst_func="rect",
        transmission=1.0,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{pixel\_size}] ?
    \item[\texttt{n\_pixels}] ?
    \item[\texttt{wl\_calibration}] ?
    \item[\texttt{int\_calibration}] ?
    \item[\texttt{width}] ?
    \item[\texttt{inst\_func}] ?
    \item[\texttt{transmission}] ?
\end{itemize}

Methods: ?

\subsection{Populating CHERAB's Atomic Database}%
\label{sec:atomic}

\texttt{populate/create}

\begin{minted}{python}
    populate_more(
        download=True,
        repository_path=None,
        adas_path="/work/projects/adas/adas/"
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{download}] -- attempt to download the ADAS files if missing;
    \item[\texttt{repository\_path}] -- alternate path for the OpenADAS repository;
    \item[\texttt{adas\_path}] -- alternate path in which to search for ADAS files;
\end{itemize}

\texttt{populate/openadas}

\begin{minted}{python}
    adas = OpenADAS(
        data_path=None,
        permit_extrapolation=False,
        missing_rates_return_null=False
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{data\_path}] -- path to atomic data repository;
    \item[\texttt{permit\_extrapolation}] -- if \mintinline{python}{True} informs interpolation objects to allow extrapolation beyond the limits of the tabulated data;
    \item[\texttt{missing\_rates\_return\_null}] -- if \mintinline{python}{True}, allows \texttt{Null} rate objects to be returned when the requested atomic data is missing.
\end{itemize}

\subsection{Utility Functions}%
\label{sec:utility}

\subsubsection{Getting Information on Plasma Parameters}%
\label{sec:info}

\dirtree{%
    .1 info/.
    .2 \_\_init\_\_.py.
    .2 beam.py.
    .2 equilibrium.py.
    .2 passive.py.
    .2 plasma.py.
    .2 profiles.py.
}

beam.py

\begin{minted}{python}
    beam_info(
        plasma=,
        id_dict=,
        plot_dict=,
        dirname=,
        config=,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{plasma}]
    \item[\texttt{id\_dict}]
    \item[\texttt{plot\_dict}]
    \item[\texttt{dirname}]
    \item[\texttt{config}]
\end{itemize}

equilibrium.py

\begin{minted}{python}
    equilibrium_info(
        id_dict=,
        plot_dict=,
        filename=,
        dirname=,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{id\_dict}]
    \item[\texttt{plot\_dict}]
    \item[\texttt{filename}]
    \item[\texttt{dirname}]
\end{itemize}

passive.py

\begin{minted}{python}
passive_info(
    plasma=,
    beam=,
    id_dict=,
    plot_dict=,
    dirname=,
)
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{plasma}]
    \item[\texttt{beam}]
    \item[\texttt{id\_dict}]
    \item[\texttt{plot\_dict}]
    \item[\texttt{dirname}]
\end{itemize}

profiles.py

\begin{minted}{python}
profiles_info(
    core_plasma=,
    edge_plasma=,
    beam=,
    id_dict=,
    plot_dict=,
    dirname=,
)
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{core\_plasma}]
    \item[\texttt{edge\_plasma}]
    \item[\texttt{beam}]
    \item[\texttt{id\_dict}]
    \item[\texttt{plot\_dict}]
    \item[\texttt{dirname}]
\end{itemize}

\subsubsection{Parsing XML Configuration File}%
\label{sec:xml}

\mint{python}{srt2bool(string="on")}
\mint{python}{bool2str(arg=True)}
\mint{python}{read_xml_entry(tree_element)}
\mint{python}{parse_user_options(section, config)}
\mint{python}{parse_emission_lines(config)}
\mint{python}{parse_diagnostic_geometry(config)}
\mint{python}{parse_dnb_parameters(config)}
\mint{python}{parse_wavelength_ranges(config)}

\subsubsection{Setting Emission Parameters}%
\label{sec:emission}

\begin{minted}{python}
    plasma_emission_parameters = plasma_emission(
        plasma=,
        lines=,
        bremsstrahlung=False,
        recombination=False,
        excitation=False,
        passive=False,
    )
\end{minted}

\begin{itemize}[align=left]
    \item[\texttt{plasma}]
    \item[\texttt{lines}]
    \item[\texttt{bremsstrahlung}]
    \item[\texttt{recombination}]
    \item[\texttt{excitation}]
    \item[\texttt{passive}]
\end{itemize}

\subsubsection{Math Functions}%
\label{sec:math}

\subsubsection{Fitting Routine}%
\label{sec:fitting}

\subsubsection{Others}%
\label{sec:other}

utility/annotation
utility/data
utility/timer
utility/fit

\end{document}